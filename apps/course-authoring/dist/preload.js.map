{"mappings":"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","sources":["apps/course-authoring/src/main/services/file-system/archiver.ts","apps/course-authoring/src/main/services/file-system/dialog.ts","apps/course-authoring/src/main/services/file-system/files.ts","apps/course-authoring/src/main/services/templater/index.ts","apps/course-authoring/src/main/services/exporter/index.ts","apps/course-authoring/src/main/services/internal-storage/database.tsx","apps/course-authoring/src/main/services/internal-storage/models/preferences.tsx","apps/course-authoring/src/main/services/internal-storage/index.tsx","apps/course-authoring/src/main/models/project/project-model.ts","apps/course-authoring/src/main/models/index.ts","apps/course-authoring/src/main/preload.ts"],"sourcesContent":["import AdmZip from 'adm-zip';\nimport { SaveFileData } from './types';\n\nexport const archive = (source: string, dest: string): SaveFileData => {\n  try {\n    const zip = new AdmZip();\n\n    zip.addLocalFolder(source);\n\n    zip.writeZip(dest);\n\n    return {\n      error: false,\n      filePath: dest,\n    };\n  } catch (err) {\n    return {\n      error: true,\n      message: err,\n    };\n  }\n};\n\nexport default {\n  archive,\n};\n","import { dialog, OpenDialogOptions, SaveDialogOptions } from 'electron';\nimport { OpenFileData, SaveFileData, FileFilters, AllowedFiles } from './types';\n\nexport const MEDIA_TYPES: FileFilters = {\n  image: { name: 'Image', extensions: ['jpg', 'jpeg', 'png'] },\n  video: { name: 'Video', extensions: ['mp4', 'mkv', 'avi'] },\n  project: { name: 'Scrowl Project', extensions: ['scrowl'] },\n};\n\nexport const getDialogMediaFilters = (filters: Array<AllowedFiles>) => {\n  return filters.map(filter => MEDIA_TYPES[filter]);\n};\n\nexport const dialogOpen = (options: OpenDialogOptions) => {\n  return new Promise<OpenFileData>((resolve, reject) => {\n    dialog\n      .showOpenDialog(options)\n      .then(({ canceled, filePaths }: OpenFileData) => {\n        resolve({\n          error: false,\n          canceled,\n          filePaths,\n        });\n      })\n      .catch(err => {\n        reject({\n          filePaths: [],\n          canceled: false,\n          error: true,\n          message: err,\n        });\n      });\n  });\n};\n\nexport const dialogSave = (options: SaveDialogOptions) => {\n  return new Promise<SaveFileData>((resolve, reject) => {\n    dialog\n      .showSaveDialog(options)\n      .then(({ canceled, filePath }: SaveFileData) => {\n        resolve({\n          error: false,\n          canceled,\n          filePath,\n        });\n      })\n      .catch(err => {\n        reject({\n          filePath: '',\n          canceled: false,\n          error: true,\n          message: err,\n        });\n      });\n  });\n};\n\nexport default {\n  dialogOpen,\n  dialogSave,\n};\n","import fs from 'fs-extra';\nimport os from 'os';\nimport path from 'path';\nimport { FileData } from './types';\n\nconst normalize = (pathName: string) => {\n  return path.normalize(pathName);\n};\n\nconst isJSON = (name: string) => {\n  return /.json$/.test(name) || /.project$/.test(name);\n};\n\nexport const join = (...paths: Array<string>) => {\n  return path.join.apply(null, paths);\n};\n\nexport const ext = (pathName: string) => {\n  return path.extname(pathName);\n};\n\nexport const dirExistsSync = (pathName: string) => {\n  try {\n    return {\n      error: false,\n      exists: fs.existsSync(normalize(pathName)),\n    };\n  } catch (err) {\n    return {\n      error: true,\n      exists: false,\n      message: err,\n    };\n  }\n};\n\nexport const dirTempSync = (prefix: string) => {\n  let tmpDir;\n\n  try {\n    tmpDir = fs.mkdtempSync(\n      path.join(os.tmpdir(), `${prefix ? `${prefix}_` : ''}`)\n    );\n\n    return {\n      error: false,\n      pathName: tmpDir,\n    };\n  } catch (err) {\n    return {\n      error: true,\n      message: err,\n    };\n  }\n};\n\nexport const fileExistsSync = (pathName: string) => {\n  try {\n    return {\n      error: false,\n      exists: fs.pathExistsSync(pathName),\n    };\n  } catch (err) {\n    return {\n      error: true,\n      exists: false,\n      message: err,\n    };\n  }\n};\n\nexport const fileReadSync = (\n  pathName: string,\n  media: BufferEncoding = 'utf8'\n) => {\n  const exists = fileExistsSync(pathName);\n\n  if (exists.error) {\n    return {\n      error: true,\n      message: exists.message,\n    };\n  }\n\n  if (media === undefined) {\n    media = 'utf8';\n  }\n\n  const filename = normalize(pathName);\n\n  try {\n    let contents;\n    const file = fs.readFileSync(filename, { encoding: media, flag: 'r' });\n\n    if (isJSON(filename)) {\n      contents = JSON.parse(file);\n    } else {\n      contents = file;\n    }\n\n    return {\n      error: false,\n      contents,\n    };\n  } catch (err) {\n    return {\n      error: true,\n      message: err,\n    };\n  }\n};\n\nexport const fileWriteSync = (\n  pathName: string,\n  contents: unknown\n): FileData => {\n  const filename = normalize(pathName);\n\n  if (!contents) {\n    return {\n      error: true,\n      filename,\n      message: 'no contents to write',\n    };\n  }\n\n  try {\n    if (isJSON(pathName)) {\n      if (typeof contents !== 'string') {\n        contents = JSON.stringify(contents, null, 2);\n      } else {\n        contents = JSON.stringify(JSON.parse(contents), null, 2);\n      }\n    }\n\n    fs.outputFileSync(filename, contents);\n\n    return {\n      error: false,\n      filename,\n    };\n  } catch (err) {\n    return {\n      error: true,\n      filename,\n      message: err,\n    };\n  }\n};\n\nexport const fileCopySync = (source: string, dest: string): FileData => {\n  const sourcePath = normalize(source);\n  const destPath = normalize(dest);\n\n  try {\n    fs.copySync(sourcePath, destPath);\n\n    return {\n      error: false,\n      filename: destPath,\n    };\n  } catch (err) {\n    return {\n      error: true,\n      message: err,\n    };\n  }\n};\n\nexport const fileTempSync = (source: string, dest: string): FileData => {\n  const destFile = `${dest}/${path.basename(source)}`;\n\n  return fileCopySync(source, destFile);\n};\n\nexport default {\n  join,\n  ext,\n  dirExistsSync,\n  dirTempSync,\n  fileExistsSync,\n  fileReadSync,\n  fileWriteSync,\n  fileCopySync,\n  fileTempSync,\n};\n","import engine from 'handlebars';\nimport { TemplateData, TemplateResult } from '../exporter/types';\n\nengine.registerHelper('raw', options => {\n  return options.fn();\n});\n\nexport const compile = (contents: string, data: TemplateData): TemplateResult => {\n  try {\n    return {\n      error: false,\n      data: engine.compile(contents)(data),\n    };\n  } catch (err: any) {\n    return {\n      error: true,\n      message: err,\n    }\n  }\n};\n\nexport default {\n  compile,\n};\n","import path from 'path';\nimport fs from 'fs-extra';\nimport { ipcMain } from 'electron';\nimport packager from 'scorm-packager';\nimport { ProjectConfig } from '@scrowl/player/src/lib';\nimport { PathingProps, PathingDirKey } from './types';\nimport { fileReadSync, fileWriteSync } from '../file-system';\nimport { compile } from '../templater';\n\nconst pathing: PathingProps = {\n  files: {\n    template: {\n      source: path.join(__dirname, 'course/templates/index.hbs'),\n      dest: path.join(__dirname, 'course/package/content/index.html'),\n    },\n  },\n  dirs: {\n    source: path.join(__dirname, 'course/package'),\n    out: path.join(__dirname, 'course/dist'),\n  }\n};\n\nconst setPathingDirs = () => {\n  let dest = '' as PathingDirKey;\n\n  for (dest in pathing.dirs) {\n    if (!fs.existsSync(pathing.dirs[dest])) {\n      fs.mkdirSync(pathing.dirs[dest]);\n    }\n  }\n};\n\nexport const pack = (ev: Electron.IpcMainInvokeEvent, packOptions: {\n  title?: string,\n  manifest?: ProjectConfig\n}) => {\n  return new Promise((resolve, reject) => {\n    const config = {\n      version: '1.2',\n      organization: 'OSG',\n      language: 'en-US',\n      startingPage: 'content/index.html',\n      source: pathing.dirs.source,\n      package: {\n        version: '0.0.1',\n        zip: true,\n        outputFolder: pathing.dirs.out,\n      },\n    };\n    const courseTemplate = fileReadSync(pathing.files.template.source);\n\n    if (courseTemplate.error) {\n      reject(courseTemplate);\n      return;\n    }\n\n    if (!packOptions.manifest) {\n      reject(\n        {\n          error: true,\n          message: 'Missing project manifest'\n        }\n      );\n      return;\n    }\n\n    const courseData = {\n      title: packOptions.title ? packOptions.title : '',\n      manifest: JSON.stringify(packOptions.manifest),\n    }\n    const courseContents = compile(courseTemplate.contents, courseData);\n\n    if (courseContents.error) {\n      reject(courseContents);\n      return;\n    }\n\n    const writeRes = fileWriteSync(pathing.files.template.dest, courseContents.data);\n\n    if (writeRes.error) {\n      reject(writeRes);\n      return;\n    }\n\n    setPathingDirs();\n    packager(config, (msg: string) => {\n      resolve({\n        error: false,\n        message: msg,\n      });\n    });\n  });\n};\n\nexport const EVENTS = {\n  package: 'package-course',\n};\n\nexport const init = () => {\n  ipcMain.handle(EVENTS.package, pack);\n};\n\nexport default {\n  EVENTS,\n  init,\n  pack,\n};\n","import knex from 'knex';\nimport path from 'path';\n\nconst database = knex({\n  client: 'sqlite3',\n  connection: {\n    filename: path.join(__dirname, './scrowl.sqlite'),\n  },\n  useNullAsDefault: true,\n});\n\nexport default database;\n","import { ipcMain } from 'electron';\nimport { default as PreferencesHandler } from '../handlers/preferences';\nimport { Preferences } from '../handlers/preferences/index.types';\n\nexport const events = {\n  getPreferencesList: 'get-preferences-list',\n  getPreference: 'get-preference',\n  setPreferences: 'set-preferences',\n};\n\nexport const getPreferencesList = () => {\n  return PreferencesHandler.getPreferencesList();\n};\n\nexport const getPreference = (\n  event: Electron.IpcMainInvokeEvent,\n  args: keyof Preferences\n) => {\n  return PreferencesHandler.getPreference(args);\n};\n\nexport const setPreferences = (\n  event: Electron.IpcMainInvokeEvent,\n  args: Preferences\n) => {\n  return PreferencesHandler.setPreferences(args);\n};\n\nexport const init = () => {\n  ipcMain.handle(events.getPreferencesList, getPreferencesList);\n  ipcMain.handle(events.getPreference, (event, args) =>\n    getPreference(event, args)\n  );\n  ipcMain.handle(events.setPreferences, (event, args) =>\n    setPreferences(event, args)\n  );\n};\n\nexport default {\n  events,\n  getPreferencesList,\n  getPreference,\n  setPreferences,\n  init,\n};\n","import * as Preferences from './models/preferences';\n\nexport const preferencesEvents = Preferences.events;\nexport const preferencesInit = Preferences.init;\n\nexport default { preferencesEvents, preferencesInit };\n","import { IpcMainInvokeEvent } from 'electron';\nimport { ModelEventProps } from '../index';\nimport {\n  dialogSave,\n  archive,\n  dirTempSync,\n  fileWriteSync,\n  fileTempSync,\n  AllowedFiles,\n  getDialogMediaFilters,\n  dialogOpen,\n  FileData,\n} from '../../services/file-system/index';\n\nexport const create = function (event: IpcMainInvokeEvent, project: unknown) {\n  const dirPrefix = 'scrowl';\n  const projectFileName = 'scrowl.project';\n  const tempDir = dirTempSync(dirPrefix);\n\n  if (tempDir.error) {\n    return tempDir;\n  }\n\n  const filename = `${tempDir.pathName}/${projectFileName}`;\n  return fileWriteSync(filename, project);\n};\n\nconst write = function (source: string, filename: string): FileData {\n  if (!source) {\n    return {\n      error: true,\n      message: 'project requires a source',\n    };\n  }\n\n  if (!filename) {\n    return {\n      error: true,\n      message: 'project requires a filename',\n    };\n  }\n\n  return archive(source, filename);\n};\n\nexport const save = async function (\n  event: IpcMainInvokeEvent,\n  projectTempPath: string,\n  projectPath: string\n) {\n  const dialogOptions = {\n    title: 'Scrowl - Save Project',\n    filters: [\n      {\n        name: 'Scrowl Project',\n        extensions: ['scrowl'],\n      },\n    ],\n  };\n\n  if (!projectPath) {\n    const dialogResult = await dialogSave(dialogOptions);\n\n    if (dialogResult.error) {\n      return dialogResult;\n    }\n\n    if (dialogResult.filePath) {\n      projectPath = dialogResult.filePath;\n    }\n  }\n\n  return write(projectTempPath, projectPath);\n};\n\nexport const importFile = async function (\n  event: IpcMainInvokeEvent,\n  fileTypes: Array<AllowedFiles>,\n  projectTempPath: string\n) {\n  const filters = getDialogMediaFilters(fileTypes);\n\n  if (!filters.length) {\n    return {\n      error: true,\n      message: 'valid file types need to be declared for importing',\n    };\n  }\n\n  const dialogOptions = {\n    title: 'Scrowl - Import File',\n    filters,\n  };\n  const dialogResult = await dialogOpen(dialogOptions);\n\n  if (dialogResult.error) {\n    return dialogResult;\n  }\n\n  if (!dialogResult.filePaths.length) {\n    return {\n      error: true,\n      message: 'no files found/selected',\n    };\n  }\n\n  return fileTempSync(dialogResult.filePaths[0], projectTempPath);\n};\n\nexport const EVENTS: ModelEventProps[] = [\n  {\n    name: 'project-create',\n    fn: create,\n  },\n  {\n    name: 'project-save',\n    fn: save,\n  },\n  {\n    name: 'project-import',\n    fn: importFile,\n  },\n];\n\nexport default {\n  EVENTS,\n  create,\n  save,\n};\n","import { ipcMain, IpcMainInvokeEvent } from 'electron';\nimport * as projects from './project/project-model';\n\nexport type ModelEventProps = {\n  name: string;\n  fn: HandleListenerProps;\n};\n\ntype HandleListenerProps = (event: IpcMainInvokeEvent, ...args: any[]) => void;\n\ninterface ModelProps {\n  EVENTS: ModelEventProps[];\n  [key: string]: unknown;\n}\n\nconst models = [projects];\n\nconst registerEvents = (model: ModelProps) => {\n  model.EVENTS.forEach((ev: ModelEventProps) => {\n    if (ev.fn && typeof ev.fn === 'function') {\n      ipcMain.handle(ev.name, ev.fn);\n    }\n  });\n};\n\nexport const init = () => {\n  models.forEach(model => {\n    if (model.EVENTS) {\n      registerEvents(model);\n    }\n  });\n};\n\nexport const getEvents = () => {\n  const getEventNames = (ev: ModelEventProps) => {\n    return ev.name;\n  };\n\n  return models\n    .map(model => {\n      return model.EVENTS ? model.EVENTS.map(getEventNames) : [];\n    })\n    .flat();\n};\n\nexport default {\n  init,\n  getEvents,\n};\n","import { contextBridge, ipcRenderer } from 'electron';\nimport { EVENTS as exporterEvents } from './services/exporter';\nimport { preferencesEvents } from './services/internal-storage';\nimport { getEvents as getModelEvents } from './models/index';\n\nconst validChannels = [\n  exporterEvents.package,\n  preferencesEvents.getPreferencesList,\n  preferencesEvents.getPreference,\n  preferencesEvents.setPreferences,\n].concat(getModelEvents());\n\ncontextBridge.exposeInMainWorld('electronAPI', {\n  ipcRenderer: {\n    invoke(channel: string, ...args: unknown[]) {\n      if (validChannels.includes(channel)) {\n        return ipcRenderer.invoke(channel, ...args);\n      }\n    },\n  },\n});\n"],"names":["$f538c121c8411ad9$export$a95942469f0fbfa1","source","dest","zip","$parcel$interopDefault","$jKToa$admzip","addLocalFolder","writeZip","error","filePath","err","message","$b4730b00f07e60e6$export$86d3e91ec655a54c","image","name","extensions","video","project","$b4730b00f07e60e6$export$a85fefe9f9398bfb","options","Promise","resolve","reject","$jKToa$electron","dialog","showOpenDialog","then","canceled","filePaths","catch","$b4730b00f07e60e6$export$99bd1e12f062b027","showSaveDialog","$0688521469908ca6$var$normalize","pathName","$jKToa$path","normalize","$0688521469908ca6$var$isJSON","test","$0688521469908ca6$export$a0f3b6799fdd398e","prefix","tmpDir","$jKToa$fsextra","mkdtempSync","join","$jKToa$os","tmpdir","$0688521469908ca6$export$5130d5f6c93c72f7","contents","filename","JSON","stringify","parse","outputFileSync","$0688521469908ca6$export$83eb0cf7b57d2792","sourcePath","destPath","copySync","$0688521469908ca6$export$9cc06fd6c62f44ff","destFile","basename","$jKToa$handlebars","registerHelper","fn","$a3981526a2cac1f8$var$__dirname","$a3981526a2cac1f8$export$fa3d5b535a2458a1","package","$jKToa$knex","client","connection","$09fe1bcaf772acc2$var$__dirname","useNullAsDefault","$e5bcd470c1e05699$export$4bf9923669ad6c63","getPreferencesList","getPreference","setPreferences","$a33e2ebf7a487d29$export$d0cca15b956387fe","$b0efd352bab00d6f$export$185802fd694ee1f5","event","tempDir","$b0efd352bab00d6f$export$a1544dad697b423d","async","projectTempPath","projectPath","dialogOptions","title","filters","dialogResult","$b0efd352bab00d6f$export$4da7403fdb9cb456","fileTypes","map","filter","$b4730b00f07e60e6$export$bf923d45a46235c4","length","$b0efd352bab00d6f$export$fa3d5b535a2458a1","$b0efd352bab00d6f$export$2e2bcd8739ae039","$10d70a7411a81276$var$models","$b0efd352bab00d6f$exports","$10d70a7411a81276$export$3f41ece7d7128238","getEventNames","ev","model","EVENTS","flat","$84fff551af772094$var$validChannels","concat","contextBridge","exposeInMainWorld","ipcRenderer","invoke","channel","args","includes"],"version":3,"file":"preload.js.map"}